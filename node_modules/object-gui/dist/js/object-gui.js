/*!
 * Author : Matteo Bruni - https://www.matteobruni.it
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://editor.matteobruni.it/
 * GitHub : https://www.github.com/matteobruni/object-gui
 * How to use? : Check the GitHub README
 * v1.1.1
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Editor": () => (/* reexport */ Editor),
  "EditorButton": () => (/* reexport */ EditorButton),
  "EditorCheckboxInput": () => (/* reexport */ EditorCheckboxInput),
  "EditorColorInput": () => (/* reexport */ EditorColorInput),
  "EditorGroup": () => (/* reexport */ EditorGroup),
  "EditorItem": () => (/* reexport */ EditorItem),
  "EditorNumberInput": () => (/* reexport */ EditorNumberInput),
  "EditorSelectInput": () => (/* reexport */ EditorSelectInput),
  "EditorStringInput": () => (/* reexport */ EditorStringInput),
  "EditorType": () => (/* reexport */ EditorType)
});

;// CONCATENATED MODULE: ./dist/js/Editors/EditorItem.js
class EditorItem {
  constructor(data, createElement) {
    this.data = data;
    this.createElement = createElement;
    this.element = this.createElement();
    this.collapsed = true;
  }

  updateCollapse(collapsed) {
    this.collapsed = collapsed;
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorButton.js

class EditorButton extends EditorItem {
  constructor(data, id, name, label, autoMap = true) {
    super(data, () => document.createElement("button"));
    this.id = id;
    this.name = name;
    this.label = label;
    this.autoMap = autoMap;
    this.element.id = `button_${this.id}`;
    this.element.innerText = this.label;
    this.element.addEventListener("click", () => {
      if (this.autoMap) {
        const obj = this.data;
        const func = obj[this.name];

        if (typeof func === "function") {
          func.bind(obj)();
        }
      }

      if (this.clickHandler) {
        this.clickHandler();
      }
    });
  }

  click(clickHandler) {
    this.clickHandler = clickHandler;
    return this;
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorInputBase.js

class EditorInputBase extends EditorItem {
  constructor(data, createElement, id, name, getDefaultValue, transformValue, getValueFromInput, setValueToInput, value, autoMap = true) {
    super(data, createElement);
    this.id = id;
    this.name = name;
    this.getDefaultValue = getDefaultValue;
    this.transformValue = transformValue;
    this.getValueFromInput = getValueFromInput;
    this.setValueToInput = setValueToInput;
    this.autoMap = autoMap;
    const input = this.element;
    const obj = this.data;
    input.id = `input_${this.id}`;
    this.value = transformValue(value !== null && value !== void 0 ? value : this.autoMap ? obj[this.name] : this.getDefaultValue());
    this.setValueToInput(this, this.value);
  }

  change(changeHandler) {
    this.changeHandler = changeHandler;
    return this;
  }

  changeEventHandler() {
    this.value = this.getValueFromInput(this);

    if (this.autoMap) {
      const obj = this.data;
      obj[this.name] = this.value;
    }

    if (this.changeHandler) {
      this.changeHandler(this.value);
    }
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorCheckboxInput.js

class EditorCheckboxInput extends EditorInputBase {
  constructor(data, id, name, value, autoMap = true) {
    super(data, () => document.createElement("input"), id, name, () => false, value => value, self => {
      const input = self.element;
      return input.checked;
    }, (self, value) => {
      const input = self.element;
      input.checked = value;
    }, value, autoMap);
    const input = this.element;
    input.type = "checkbox";
    input.addEventListener("change", () => {
      this.changeEventHandler();
    });
    this.fullDom = document.createElement("div");
    this.fullDom.append(this.element);
    const spacer = document.createElement("div");
    spacer.classList.add("editor-spacer");
    this.fullDom.append(spacer);
  }

  addItem() {
    return this;
  }

  addItemGroup() {
    return this;
  }

  addItems() {
    return this;
  }

  max() {
    return this;
  }

  min() {
    return this;
  }

  step() {
    return this;
  }

}
;// CONCATENATED MODULE: ./dist/js/Utils/ColorUtils.js
class ColorUtils {
  static stringToRgb(input) {
    return ColorUtils.stringToRgba(input);
  }

  static hslToRgb(hsl) {
    const result = {
      b: 0,
      g: 0,
      r: 0
    };
    const hslPercent = {
      h: hsl.h / 360,
      l: hsl.l / 100,
      s: hsl.s / 100
    };

    if (hslPercent.s === 0) {
      result.b = hslPercent.l;
      result.g = hslPercent.l;
      result.r = hslPercent.l;
    } else {
      const q = hslPercent.l < 0.5 ? hslPercent.l * (1 + hslPercent.s) : hslPercent.l + hslPercent.s - hslPercent.l * hslPercent.s;
      const p = 2 * hslPercent.l - q;
      result.r = ColorUtils.hue2rgb(p, q, hslPercent.h + 1 / 3);
      result.g = ColorUtils.hue2rgb(p, q, hslPercent.h);
      result.b = ColorUtils.hue2rgb(p, q, hslPercent.h - 1 / 3);
    }

    result.r = Math.floor(result.r * 255);
    result.g = Math.floor(result.g * 255);
    result.b = Math.floor(result.b * 255);
    return result;
  }

  static hslaToRgba(hsla) {
    const rgbResult = ColorUtils.hslToRgb(hsla);
    return {
      a: hsla.a,
      b: rgbResult.b,
      g: rgbResult.g,
      r: rgbResult.r
    };
  }

  static hsvToRgb(hsv) {
    const result = {
      b: 0,
      g: 0,
      r: 0
    };
    const hsvPercent = {
      h: hsv.h / 60,
      s: hsv.s / 100,
      v: hsv.v / 100
    };
    const c = hsvPercent.v * hsvPercent.s,
          x = c * (1 - Math.abs(hsvPercent.h % 2 - 1));
    let tempRgb;

    if (hsvPercent.h >= 0 && hsvPercent.h <= 1) {
      tempRgb = {
        r: c,
        g: x,
        b: 0
      };
    } else if (hsvPercent.h > 1 && hsvPercent.h <= 2) {
      tempRgb = {
        r: x,
        g: c,
        b: 0
      };
    } else if (hsvPercent.h > 2 && hsvPercent.h <= 3) {
      tempRgb = {
        r: 0,
        g: c,
        b: x
      };
    } else if (hsvPercent.h > 3 && hsvPercent.h <= 4) {
      tempRgb = {
        r: 0,
        g: x,
        b: c
      };
    } else if (hsvPercent.h > 4 && hsvPercent.h <= 5) {
      tempRgb = {
        r: x,
        g: 0,
        b: c
      };
    } else if (hsvPercent.h > 5 && hsvPercent.h <= 6) {
      tempRgb = {
        r: c,
        g: 0,
        b: x
      };
    }

    if (tempRgb) {
      const m = hsvPercent.v - c;
      result.r = Math.floor((tempRgb.r + m) * 255);
      result.g = Math.floor((tempRgb.g + m) * 255);
      result.b = Math.floor((tempRgb.b + m) * 255);
    }

    return result;
  }

  static mix(color1, color2, size1, size2) {
    const mix = (comp1, comp2, weight1, weight2) => Math.floor((comp1 * weight1 + comp2 * weight2) / (weight1 + weight2));

    let rgb1 = color1;
    let rgb2 = color2;

    if (rgb1.r === undefined) {
      rgb1 = ColorUtils.hslToRgb(color1);
    }

    if (rgb2.r === undefined) {
      rgb2 = ColorUtils.hslToRgb(color2);
    }

    return {
      b: mix(rgb1.b, rgb2.b, size1, size2),
      g: mix(rgb1.g, rgb2.g, size1, size2),
      r: mix(rgb1.r, rgb2.r, size1, size2)
    };
  }

  static hue2rgb(p, q, t) {
    let tCalc = t;

    if (tCalc < 0) {
      tCalc += 1;
    }

    if (tCalc > 1) {
      tCalc -= 1;
    }

    if (tCalc < 1 / 6) {
      return p + (q - p) * 6 * tCalc;
    }

    if (tCalc < 1 / 2) {
      return q;
    }

    if (tCalc < 2 / 3) {
      return p + (q - p) * (2 / 3 - tCalc) * 6;
    }

    return p;
  }

  static stringToRgba(input) {
    if (input.startsWith("rgb")) {
      const regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i;
      const result = regex.exec(input);
      return result ? {
        a: result.length > 4 ? parseFloat(result[5]) : 1,
        b: parseInt(result[3], 10),
        g: parseInt(result[2], 10),
        r: parseInt(result[1], 10)
      } : undefined;
    } else if (input.startsWith("hsl")) {
      const regex = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i;
      const result = regex.exec(input);
      return result ? ColorUtils.hslaToRgba({
        a: result.length > 4 ? parseFloat(result[5]) : 1,
        h: parseInt(result[1], 10),
        l: parseInt(result[3], 10),
        s: parseInt(result[2], 10)
      }) : undefined;
    } else {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
      const hexFixed = input.replace(shorthandRegex, (_m, r, g, b, a) => {
        return r + r + g + g + b + b + (a !== undefined ? a + a : "");
      });
      const regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
      const result = regex.exec(hexFixed);
      return result ? {
        a: result[4] !== undefined ? parseInt(result[4], 16) / 0xff : 1,
        b: parseInt(result[3], 16),
        g: parseInt(result[2], 16),
        r: parseInt(result[1], 16)
      } : undefined;
    }
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorColorInput.js


class EditorColorInput extends EditorInputBase {
  constructor(data, id, name, value, autoMap = true) {
    super(data, () => document.createElement("input"), id, name, () => "", v => {
      let colorStringValue;

      if (v === undefined) {
        colorStringValue = undefined;
      } else if (typeof v === "string") {
        colorStringValue = v;
      } else {
        let rgb = v;
        const hsl = v;

        if (hsl.h !== undefined && hsl.l !== undefined) {
          rgb = ColorUtils.hslToRgb(hsl);
        } else {
          const hsv = v;

          if (hsv.h !== undefined && hsv.v !== undefined) {
            rgb = ColorUtils.hsvToRgb(hsv);
          }
        }

        const r = rgb.r.toString(16).padStart(2, "0"),
              g = rgb.g.toString(16).padStart(2, "0"),
              b = rgb.b.toString(16).padStart(2, "0");
        colorStringValue = `#${r}${g}${b}`;
      }

      return colorStringValue;
    }, self => {
      const inputEl = self.element;
      return inputEl.value;
    }, (self, v) => {
      const inputEl = self.element;
      inputEl.value = v;
    }, value, autoMap);
    this.fullDom = document.createElement("div");
    this.colorInput = document.createElement("input");
    this.colorInput.type = "color";
    this.colorInput.value = this.value;
    this.fullDom.append(this.colorInput);
    const input = this.element;
    input.type = "text";
    this.fullDom.append(this.element);
    this.updateStyle(input.value);
    input.addEventListener("change", () => {
      const colorInput = this.element;
      this.colorInput.value = colorInput.value;
      this.changeEventHandler();
    });
    this.colorInput.addEventListener("change", () => {
      const colorInput = this.element;
      colorInput.value = this.colorInput.value;
      this.changeEventHandler();
    });
  }

  static textColor(value) {
    if (value === undefined) {
      return undefined;
    }

    const rgb = ColorUtils.stringToRgb(value);

    if (!rgb) {
      return undefined;
    }

    const color = Math.round((rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000);
    return color > 125 ? "#000" : "#fff";
  }

  step() {
    return this;
  }

  min() {
    return this;
  }

  max() {
    return this;
  }

  addItem() {
    return this;
  }

  addItems() {
    return this;
  }

  addItemGroup() {
    return this;
  }

  changeEventHandler() {
    super.changeEventHandler();
    this.updateStyle(this.value);
  }

  updateStyle(bgColor) {
    const rgb = ColorUtils.stringToRgb(bgColor);

    if (!rgb) {
      this.element.style.backgroundColor = "";
      this.colorInput.style.backgroundColor = "";
    } else {
      this.element.style.backgroundColor = bgColor;
      this.colorInput.style.backgroundColor = bgColor;
    }

    const textColor = EditorColorInput.textColor(bgColor);

    if (textColor !== undefined) {
      this.element.style.color = textColor;
      this.colorInput.style.color = textColor;
    } else {
      this.element.style.color = "";
      this.colorInput.style.color = "";
    }
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorStringInput.js

class EditorStringInput extends EditorInputBase {
  constructor(data, id, name, value, autoMap = true) {
    super(data, () => document.createElement("input"), id, name, () => "", v => v, self => {
      const inputEl = self.element;
      return inputEl.value;
    }, (self, v) => {
      const inputEl = self.element;
      inputEl.value = v;
    }, value, autoMap);
    const input = this.element;
    input.type = "text";
    input.addEventListener("change", () => {
      this.changeEventHandler();
    });
  }

  addItem() {
    return this;
  }

  addItemGroup() {
    return this;
  }

  addItems() {
    return this;
  }

  max() {
    return this;
  }

  min() {
    return this;
  }

  step() {
    return this;
  }

}
;// CONCATENATED MODULE: ./dist/js/Utils/Utils.js
class Utils {
  static clamp(value, min, max) {
    const realMin = Math.min(min, max);
    const realMax = Math.max(min, max);
    return Math.min(Math.max(realMin, value), realMax);
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorNumberInput.js


class EditorNumberInput extends EditorInputBase {
  constructor(data, id, name, value, autoMap = true) {
    super(data, () => document.createElement("input"), id, name, () => 0, v => v, self => {
      var _a, _b;

      const numberSelf = self;
      const inputEl = numberSelf.element;
      const inputValue = parseFloat(inputEl.value);
      return Utils.clamp(inputValue, (_a = numberSelf._min) !== null && _a !== void 0 ? _a : inputValue, (_b = numberSelf._max) !== null && _b !== void 0 ? _b : inputValue);
    }, (self, v) => {
      var _a, _b;

      const numberSelf = self;
      const inputEl = numberSelf.element;
      const numValue = v;
      inputEl.value = Utils.clamp(numValue, (_a = numberSelf._min) !== null && _a !== void 0 ? _a : numValue, (_b = numberSelf._max) !== null && _b !== void 0 ? _b : numValue).toString();
    }, value, autoMap);
    const input = this.element;
    input.type = "number";
    this.fullDom = document.createElement("div");
    this.fullDom.append(this.element);
    input.addEventListener("change", () => {
      this.changeEventHandler();
    });
  }

  static getDragger(slider) {
    return slider.querySelector("span");
  }

  step(step) {
    this.element.step = step.toString(10);
    this._step = step;
    return this;
  }

  min(min) {
    this.element.min = min.toString(10);
    this._min = min;
    this.drawSlider();
    return this;
  }

  max(max) {
    this.element.max = max.toString(10);
    this._max = max;
    this.drawSlider();
    return this;
  }

  addItem() {
    return this;
  }

  addItemGroup() {
    return this;
  }

  addItems() {
    return this;
  }

  updateCollapse(collapsed) {
    super.updateCollapse(collapsed);
    const slider = this.getSlider();

    if (!slider) {
      return;
    }

    this.updateSliderData(slider);
    const dragger = EditorNumberInput.getDragger(slider);

    if (!dragger) {
      return;
    }

    this.updateDragger(dragger);
  }

  changeEventHandler() {
    super.changeEventHandler();
    const slider = this.getSlider();

    if (!slider) {
      return;
    }

    const dragger = EditorNumberInput.getDragger(slider);

    if (!dragger) {
      return;
    }

    this.updateDragger(dragger);
  }

  getSlider() {
    if (this._max === undefined || this._min === undefined) {
      return null;
    }

    const parent = this.fullDom;

    if (!parent) {
      return null;
    }

    return parent.querySelector(".range-slider");
  }

  updateSliderData(slider) {
    const rect = slider.getBoundingClientRect();
    this.slider = {
      left: rect.left,
      width: rect.width
    };
  }

  updateDragger(dragger) {
    var _a, _b;

    if (!this.slider) {
      return;
    }

    const max = (_a = this._max) !== null && _a !== void 0 ? _a : 0;
    const min = (_b = this._min) !== null && _b !== void 0 ? _b : 0;
    const value = this.value;
    const denom = max - min;
    const width = denom !== 0 ? value / denom : 0;
    dragger.style.width = `${width * this.slider.width}px`;
  }

  updateDraggerEvent(e, down, dragger) {
    var _a, _b, _c;

    if (!this.slider || !down) {
      return;
    }

    const max = (_a = this._max) !== null && _a !== void 0 ? _a : 0;
    const min = (_b = this._min) !== null && _b !== void 0 ? _b : 0;
    const step = (_c = this._step) !== null && _c !== void 0 ? _c : 0;
    const width = Utils.clamp(e.pageX - this.slider.left, 0, this.slider.width);
    let value = Utils.clamp(width / this.slider.width * (max - min) + min, min, max);

    if (step > 0) {
      value = Math.floor(value / step) * step;
    }

    dragger.style.width = `${width}px`;
    this.onDrag(value);
  }

  onDrag(value) {
    const input = this.element;
    input.value = value.toString(10);
    this.changeEventHandler();
  }

  drawSlider() {
    var _a, _b;

    if (this._max === undefined || this._min === undefined) {
      return;
    }

    const parent = this.fullDom;

    if (!parent) {
      return;
    }

    const range = parent.querySelector(".range-slider");

    if (range) {
      return;
    }

    this.element.classList.add("slider-input");
    const slider = document.createElement("div");
    slider.classList.add("range-slider");
    slider.appendChild(document.createElement("span"));
    parent.insertBefore(slider, this.element);
    const rect = slider.getBoundingClientRect();
    this.slider = {
      left: rect.left,
      width: rect.width
    };
    const dragger = slider.children[0];
    let down = false;
    const max = (_a = this._max) !== null && _a !== void 0 ? _a : 0;
    const min = (_b = this._min) !== null && _b !== void 0 ? _b : 0;
    const value = this.value;
    const denom = Math.abs(max) + Math.abs(min);
    const width = denom !== 0 ? value / denom : 0;
    dragger.style.width = `${width * this.slider.width}px`;
    dragger.style.left = "0px";
    dragger.style.marginLeft = "0px";
    slider.addEventListener("mousedown", e => {
      if (!e.target) {
        return;
      }

      down = true;
      this.updateDraggerEvent(e, down, dragger);
      return false;
    });
    document.addEventListener("mousemove", e => {
      this.updateDraggerEvent(e, down, dragger);
    });
    document.addEventListener("mouseup", () => {
      down = false;
    });
    window.addEventListener("resize", () => {
      const r = slider.getBoundingClientRect();
      this.slider = {
        left: r.left,
        width: r.width
      };
      this.updateDragger(dragger);
    });
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/EditorSelectInput.js

class EditorSelectInput extends EditorInputBase {
  constructor(data, id, name, value, autoMap = true) {
    super(data, () => document.createElement("select"), id, name, () => "", v => v, self => {
      const input = self.element;
      return input.value;
    }, (self, v) => {
      const input = self.element;
      input.value = v;
    }, value, autoMap);
    const select = this.element;
    select.addEventListener("change", () => {
      this.changeEventHandler();
    });
  }

  addItem(value, text, group) {
    const select = this.element;
    const item = document.createElement("option");
    const groupElement = select.querySelector(`[label=${group}]`);
    item.value = value;
    item.text = text !== null && text !== void 0 ? text : value;
    item.selected = this.value === value;
    (groupElement !== null && groupElement !== void 0 ? groupElement : select).append(item);
    return this;
  }

  addItems(values) {
    for (const value of values) {
      this.addItem(value.value, value.text, value.group);
    }

    return this;
  }

  addItemGroup(name) {
    const select = this.element;
    const group = document.createElement("optgroup");
    group.label = name;
    select.append(group);
    return this;
  }

  max() {
    return this;
  }

  min() {
    return this;
  }

  step() {
    return this;
  }

}
;// CONCATENATED MODULE: ./dist/js/Enums/EditorType.js
var EditorType;

(function (EditorType) {
  EditorType["number"] = "number";
  EditorType["boolean"] = "boolean";
  EditorType["color"] = "color";
  EditorType["select"] = "select";
  EditorType["string"] = "string";
})(EditorType || (EditorType = {}));
;// CONCATENATED MODULE: ./dist/js/Enums/index.js

;// CONCATENATED MODULE: ./dist/js/Editors/EditorGroup.js








class EditorGroup extends EditorItem {
  constructor(data, name, title, parent, collapsed, themeSelect) {
    super(data, () => document.createElement("div"));
    this.name = name;
    this.title = title;
    this.collapsed = collapsed;
    this.children = [];
    this.element.id = this.name;
    this.element.classList.add("editor", "editor-group");
    const divTitle = document.createElement("div");
    divTitle.classList.add("editor-item-title");
    const divName = document.createElement("div");
    divName.classList.add("editor-item-name");
    const b = document.createElement("b");
    b.textContent = this.title;
    divName.append(b);
    divTitle.append(divName);

    if (themeSelect) {
      const divTheme = document.createElement("div");
      divTheme.classList.add("editor-button-theme");
      divTheme.append(themeSelect);
      divTitle.append(divTheme);
    }

    const divCollapse = document.createElement("div");
    divCollapse.classList.add("editor-button-collapse");
    this.collapseButton = document.createElement("button");
    this.collapseButton.type = "button";
    this.collapseButton.addEventListener("click", () => {
      this.toggleCollapse();
    });
    divCollapse.append(this.collapseButton);
    divTitle.append(divCollapse);
    this.element.append(divTitle);
    this.childrenGroup = document.createElement("div");
    this.childrenGroup.classList.add("group-content");
    this.element.append(this.childrenGroup);
    parent.append(this.element);
    this.setCollapse();
  }

  static createRoot(name, title, data, parent, themeSelect) {
    return new EditorGroup(data, `${this.name}_${name}`, title, parent, false, themeSelect);
  }

  addGroup(name, title, collapsed = true, customParent) {
    const parentData = customParent !== null && customParent !== void 0 ? customParent : this.data;

    if (!parentData[name]) {
      parentData[name] = {};
    }

    const data = parentData[name];
    const subGroup = new EditorGroup(data, `${this.name}_${name}`, title, this.childrenGroup, collapsed);
    this.children.push(subGroup);
    return subGroup;
  }

  addProperty(name, label, type, value, autoMap = true) {
    const divGroup = document.createElement("div");
    divGroup.classList.add("editor-element");
    const htmlLabel = document.createElement("label");
    htmlLabel.textContent = label;
    divGroup.append(htmlLabel);
    let item;
    const inputName = `${this.name}_${name}`;

    switch (type) {
      case EditorType.number:
        item = new EditorNumberInput(this.data, inputName, name, value, autoMap);
        break;

      case EditorType.boolean:
        item = new EditorCheckboxInput(this.data, inputName, name, value, autoMap);
        break;

      case EditorType.color:
        item = new EditorColorInput(this.data, inputName, name, value, autoMap);
        break;

      case EditorType.select:
        item = new EditorSelectInput(this.data, inputName, name, value, autoMap);
        break;

      default:
        item = new EditorStringInput(this.data, inputName, name, value, autoMap);
    }

    this.children.push(item);

    if (item.fullDom) {
      item.fullDom.classList.add("element-dom");
      divGroup.append(item.fullDom);
    } else {
      divGroup.append(item.element);
    }

    this.childrenGroup.append(divGroup);
    return item;
  }

  addButton(name, label, autoMap = true) {
    const button = new EditorButton(this.data, `${this.name}_${name}`, name, label, autoMap);
    this.children.push(button);
    this.childrenGroup.append(button.element);
    return button;
  }

  toggleCollapse() {
    this.updateCollapse(!this.collapsed);
  }

  updateCollapse(collapsed) {
    super.updateCollapse(collapsed);
    this.setCollapse();
  }

  setCollapse() {
    if (this.collapsed) {
      this.childrenGroup.style.display = "none";
      this.collapseButton.textContent = "Expand";
    } else {
      this.childrenGroup.style.display = "block";
      this.collapseButton.textContent = "Collapse";
    }

    for (const child of this.children) {
      if (!(child instanceof EditorGroup) && !this.collapsed || this.collapsed) {
        child.updateCollapse(this.collapsed);
      }
    }
  }

}
;// CONCATENATED MODULE: ./dist/js/Editors/index.js








;// CONCATENATED MODULE: ./dist/js/Editor.js

class Editor {
  constructor(id, name, data) {
    if (data === null || data === undefined) {
      throw new Error("No valid data argument");
    }

    this.themeSelect = document.createElement("select");
    this.themeSelect.addEventListener("change", () => {
      this.theme(this.themeSelect.value);
    });
    this._themes = [];
    this.addTheme("ashgrey");
    this.addTheme("blue");
    this.addTheme("brown");
    this.addTheme("cyan");
    this.addTheme("dark");
    this.addTheme("fedex");
    this.addTheme("gameboy");
    this.addTheme("gold");
    this.addTheme("green");
    this.addTheme("grey");
    this.addTheme("greyorange");
    this.addTheme("light");
    this.addTheme("moonlight");
    this.addTheme("nautilus");
    this.addTheme("night-sky");
    this.addTheme("one-dark");
    this.addTheme("orange");
    this.addTheme("peach");
    this.addTheme("pink");
    this.addTheme("purple");
    this.addTheme("rebeccapurple");
    this.addTheme("red");
    this.addTheme("starbell");
    this.addTheme("sunlight");
    this.addTheme("trafficlights");
    this.addTheme("tuftsblue");
    this.addTheme("yellow");
    this.addTheme("neu-blue");
    this.addTheme("neu-caribbean");
    this.addTheme("neu-crystalgrape");
    this.addTheme("neu-dark");
    this.addTheme("neu-ecofriendly");
    this.addTheme("neu-expedia");
    this.addTheme("neu-gold");
    this.addTheme("neu-greysun");
    this.addTheme("neu-light");
    this.addTheme("neu-moon");
    this.addTheme("neu-orange");
    this.addTheme("neu-pink");
    this.addTheme("neu-silver");
    this.root = EditorGroup.createRoot(`${id}_editor`, name, data, document.body, this.themeSelect);
    const rootTitle = this.root.element.querySelector(".editor-item-title");
    const rootName = rootTitle === null || rootTitle === void 0 ? void 0 : rootTitle.querySelector(".editor-item-name");
    const rootNameB = rootTitle === null || rootTitle === void 0 ? void 0 : rootTitle.querySelector("b");
    let initialX = 0,
        initialY = 0,
        currentX = 0,
        currentY = 0,
        offsetX = 0,
        offsetY = 0;
    rootTitle === null || rootTitle === void 0 ? void 0 : rootTitle.addEventListener("mousedown", downEvent => {
      if (downEvent.target !== rootName && downEvent.target !== rootTitle && downEvent.target !== rootNameB) {
        return;
      }

      downEvent.preventDefault();
      initialX = downEvent.clientX - offsetX;
      initialY = downEvent.clientY - offsetY;
      rootTitle.classList.add("dragging");

      document.onmouseup = () => {
        document.onmouseup = null;
        document.onmousemove = null;
        initialX = currentX;
        initialY = currentY;
        rootTitle.classList.remove("dragging");
      };

      document.onmousemove = moveEvent => {
        moveEvent.preventDefault();
        currentX = moveEvent.clientX - initialX;
        currentY = moveEvent.clientY - initialY;
        offsetX = currentX;
        offsetY = currentY;
        this.root.element.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
      };
    });
    this.root.element.classList.add("editor-root");
    this.customize();
    this.top().right().theme("light");
  }

  get data() {
    return this.root.data;
  }

  addButton(name, label, autoMap = true) {
    return this.root.addButton(name, label, autoMap);
  }

  addGroup(name, title, collapsed = true, customParent) {
    return this.root.addGroup(name, title, collapsed, customParent);
  }

  addProperty(name, label, type, value, autoMap = true) {
    return this.root.addProperty(name, label, type, value, autoMap);
  }

  top() {
    this.root.element.classList.remove("editor-bottom");
    this.root.element.classList.add("editor-top");
    return this;
  }

  bottom() {
    this.root.element.classList.remove("editor-top");
    this.root.element.classList.add("editor-bottom");
    return this;
  }

  left() {
    this.root.element.classList.remove("editor-right");
    this.root.element.classList.add("editor-left");
    return this;
  }

  right() {
    this.root.element.classList.remove("editor-left");
    this.root.element.classList.add("editor-right");
    return this;
  }

  theme(theme) {
    if (theme === this.currentTheme) {
      return;
    }

    this.root.element.classList.forEach(t => {
      if (t.startsWith("editor-theme-")) {
        this.root.element.classList.remove(t);
      }
    });
    this.themeSelect.value = theme;

    for (let i = 0; i < this.themeSelect.options.length; i++) {
      const option = this.themeSelect.options.item(i);

      if (option) {
        option.selected = option.value === this.themeSelect.value;
      }
    }

    this.root.element.classList.add(`editor-theme-${theme}`);
    this.currentTheme = theme;
  }

  addTheme(theme) {
    const option = document.createElement("option");
    option.value = theme;
    option.text = theme;
    option.selected = theme === this.themeSelect.value;
    this.themeSelect.options.add(option);
  }

  themes() {
    return this._themes;
  }

  customize() {}

}
;// CONCATENATED MODULE: ./dist/js/index.js





/******/ 	return __webpack_exports__;
/******/ })()
;
});